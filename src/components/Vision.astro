---
---
<section class="vision-section" id="vision-trigger">
  <canvas id="vision-canvas" class="vision-canvas"></canvas>
  
  <div class="vision-content">
    <div class="vision-text-container" id="vision-text">
      <h2 class="vision-headline">One glance.<br/><span class="gradient-text">Complete clarity.</span></h2>
    </div>
  </div>
</section>

<style>
  .vision-section {
    position: relative;
    height: 150vh; /* Scroll space for convergence */
    background-color: var(--bg-primary);
    overflow: hidden;
  }

  .vision-canvas {
    position: sticky;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 1;
    pointer-events: auto; /* For mouse interaction */
  }

  .vision-content {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .vision-text-container {
    text-align: center;
    opacity: 0;
    transform: scale(0.9);
  }

  .vision-headline {
    font-size: clamp(32px, 6vw, 56px);
    line-height: 1.1;
  }
</style>

<script>
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  document.addEventListener('DOMContentLoaded', () => {
    gsap.registerPlugin(ScrollTrigger);

    const canvas = document.getElementById('vision-canvas') as HTMLCanvasElement;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set canvas size
    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Particle system
    const numParticles = 150;
    const particles: any[] = [];
    
    // Animation state controlled by GSAP
    const state = {
      convergence: 0 // 0 = random, 1 = centered
    };

    // Mouse interaction
    const mouse = { x: -1000, y: -1000 };
    canvas.addEventListener('mousemove', (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });
    canvas.addEventListener('mouseleave', () => {
      mouse.x = -1000;
      mouse.y = -1000;
    });

    // Initialize particles
    for (let i = 0; i < numParticles; i++) {
        // distribute them randomly
      particles.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        baseX: Math.random() * window.innerWidth,
        baseY: Math.random() * window.innerHeight,
        vx: (Math.random() - 0.5) * 1,
        vy: (Math.random() - 0.5) * 1,
        radius: Math.random() * 2 + 1,
        color: `rgba(${Math.floor(100 + Math.random() * 100)}, ${Math.floor(150 + Math.random() * 105)}, 255, ${Math.random() * 0.5 + 0.3})`
      });
    }

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // Draw center pulse when converged
      if (state.convergence > 0.8) {
        const pulseRatio = (state.convergence - 0.8) * 5; // 0 to 1
        ctx.beginPath();
        const grad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 150 * pulseRatio);
        grad.addColorStop(0, `rgba(59, 130, 246, ${0.2 * pulseRatio})`);
        grad.addColorStop(1, 'rgba(59, 130, 246, 0)');
        ctx.fillStyle = grad;
        ctx.arc(centerX, centerY, 150 * pulseRatio, 0, Math.PI * 2);
        ctx.fill();
      }

      for (let i = 0; i < numParticles; i++) {
        const p = particles[i];
        
        // Target is either base position or center, depending on convergence
        const targetX = p.baseX * (1 - state.convergence) + centerX * state.convergence;
        const targetY = p.baseY * (1 - state.convergence) + centerY * state.convergence;
        
        // Move towards target
        p.x += (targetX - p.x) * 0.05;
        p.y += (targetY - p.y) * 0.05;
        
        // Add subtle floating motion
        if (state.convergence < 1) {
            p.x += p.vx;
            p.y += p.vy;
            
            // Bounce off "walls" of bounding box
            if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
            if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
        }

        // Mouse repel logic
        const dx = mouse.x - p.x;
        const dy = mouse.y - p.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 100) {
            const force = (100 - dist) / 100;
            p.x -= (dx / dist) * force * 5;
            p.y -= (dy / dist) * force * 5;
        }

        // Draw particle
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.fill();
        
        // Add glow to particle
        ctx.shadowBlur = 10;
        ctx.shadowColor = p.color;
      }
      
      ctx.shadowBlur = 0; // reset
      requestAnimationFrame(animate);
    };
    
    animate();

    // GSAP ScrollTrigger for convergence
    gsap.to(state, {
      convergence: 1,
      ease: "none",
      scrollTrigger: {
        trigger: "#vision-trigger",
        start: "top top",
        end: "+=100%", // scroll for 100% of viewport height
        scrub: true,
      }
    });

    // Reveal text when converged
    gsap.to("#vision-text", {
      opacity: 1,
      scale: 1,
      scrollTrigger: {
        trigger: "#vision-trigger",
        start: "center top",
        end: "+=50%",
        scrub: true,
      }
    });

  });
</script>
